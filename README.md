# Cyber-Attack Detection in a Smart Home System

This project implements a rule-based anomaly detection system designed to identify potential cyber-attacks within a simulated smart home environment. It monitors various events and user activities, applying a set of rules to flag suspicious behavior that might indicate an attack.

## Project Structure

- `main.py`: Contains the core `AttackDetector` class, which implements the detection logic for various attack scenarios.
- `test_main.py`: Includes comprehensive unit tests for the `AttackDetector` class, ensuring the reliability of the detection mechanisms.
- `testing.ipynb`: A Jupyter Notebook that demonstrates the functionality of the `AttackDetector` with various normal and attack scenarios.
- `suspicious_patterns.json`: A configuration file listing known suspicious command patterns. This file is used by the `AttackDetector` to identify malicious commands.
- `security_alerts.json`: This file is generated by `main.py` when threats are detected. It logs all alerts with details.

## Features

The `AttackDetector` can identify several types of anomalies and potential attacks:

1. **Failed Login Attacks (Brute Force):** Detects multiple failed login attempts from the same source within a short time window.
2. **Device Toggle Spam:** Identifies an unusually high frequency of device toggle commands, which might indicate a denial-of-service attempt or a compromised device.
3. **Power Anomalies:**
   - Detects invalid power readings (e.g., negative values).
   - Flags significant power spikes compared to historical averages for a device.
4. **Suspicious Command Patterns:**
   - Matches executed commands against a list of known malicious patterns (e.g., `rm -rf /`, `curl http://malicious.com`).
   - Detects an excessive number of commands executed by a user from a specific source in a short period.
5. **Session Hijacking:**
   - Monitors session tokens and flags if a session is used from a different IP address or with a different User-Agent string within a short timeframe, suggesting a compromised session.
   - Considers session timeouts to allow legitimate changes in IP/User-Agent after a period of inactivity.
6. **Role-Aware Filtering:** For users with "ADMIN" or "MANAGER" roles, certain alerts (e.g., failed logins, toggle spam, power anomalies, suspicious commands, session hijacking) are suppressed if the activity occurs during defined business hours (8 AM - 6 PM). This helps reduce false positives for legitimate administrative actions.

## How to Run

### Prerequisites

- Python 3.11+
- No external libraries are strictly required for `main.py` and `test_main.py` beyond the standard library.
- For `testing.ipynb`, you'll need Jupyter Notebook or JupyterLab installed:

  ```bash
  pip install jupyterlab
  ```

### 1. Running the Demonstration (Jupyter Notebook)

The `testing.ipynb` notebook provides an interactive way to see the `AttackDetector` in action.

1. Navigate to the project directory:
   ```bash
   cd ""
   ```
2. Start Jupyter Lab (or Jupyter Notebook):
   ```bash
   jupyter lab
   # or
   jupyter notebook
   ```
3. Open `testing.ipynb` in your browser and run the cells sequentially. The notebook demonstrates:
   - Initialization of the `AttackDetector`.
   - Simulation of normal operations (which should not trigger alerts).
   - Simulation of various attack scenarios (brute force, toggle spam, power anomalies, suspicious commands, session hijacking).
   - Demonstration of role-aware filtering during business and non-business hours.

### 2. Running the Main Script (Directly - for integration)

The `main.py` script primarily defines the `AttackDetector` class. It's not designed to be run as a standalone executable that continuously monitors a system but rather to be integrated into a larger smart home event processing pipeline.

You can, however, import and use the `AttackDetector` in your own Python scripts:

```python
# example_usage.py
from main import AttackDetector
from datetime import datetime

detector = AttackDetector()

# Simulate an event
threat_detected = detector.instrument(
    event_name="login_attempt",
    user_role="USER",
    user_id="test_user",
    source_id="192.168.1.100",
    context={"success": False}
)

if threat_detected:
    print("Threat detected!")
else:
    print("No threat detected.")

# Get a summary of all detected threats
summary = detector.get_threat_summary()
print(summary)
```

### 3. Running Unit Tests

The `test_main.py` file contains comprehensive unit tests for the `AttackDetector`.

1. Navigate to the project directory:
   ```bash
   cd ""
   ```
2. Run the tests using Python's `unittest` module:
   ```bash
   python -m unittest test_main.py
   ```
   Or, run the test file directly:
   ```bash
   python test_main.py
   ```

The tests will verify each detection mechanism under various conditions, including edge cases and role-aware filtering.

#### Test Coverage

The unit tests cover:
- **Brute Force Login Detection**: Tests threshold triggering, time windows, and admin exemptions during business hours
- **Device Toggle Spam**: Tests rapid toggle detection and admin exemptions
- **Power Anomaly Detection**: Tests spike detection, invalid values, and admin exemptions
- **Suspicious Command Patterns**: Tests pattern matching, excessive commands, file handling, and admin exemptions
- **Session Hijacking Detection**: Tests IP changes, User-Agent changes, session timeouts, and admin exemptions
- **Role-Aware Filtering**: Tests business hours logic for admin/manager roles
- **File Operations**: Tests alert logging and error handling
- **Summary Generation**: Tests threat summary statistics

## Configuration

### `suspicious_patterns.json`

This JSON file contains a list of command patterns that are considered suspicious. The `AttackDetector` loads these patterns to identify potentially malicious commands.

Example format:

```json
{
  "suspicious_patterns": [
    "rm -rf",
    "del /s",
    "format c:",
    "sudo su",
    "cat /etc/passwd",
    "curl http://malicious.com",
    "wget http://evil-site.net"
  ]
}
```

If this file is not found, the detector falls back to a default list of suspicious patterns defined internally.

### `security_alerts.json`

Whenever a threat is detected by the `AttackDetector`, an entry is logged into `security_alerts.json`. Each entry is a JSON object containing details about the event, including timestamp, event name, user information, source, context, threat level, and a description of the threat.

Example entry:
```json
{"timestamp": "2023-10-27T10:15:30.123456", "event_name": "login_attempt", "user_role": "", "user_id": "attacker_user", "source_id": "192.168.1.666", "context": {"success": false}, "threat_level": "HIGH", "description": "Brute force attack detected: 6 failed logins from 192.168.1.666 in 1 minutes"}
```

## API Reference

### AttackDetector Class

#### `__init__()`
Initializes the detector with default configuration values and empty tracking structures.

#### `instrument(event_name, user_role, user_id, source_id, timestamp=None, context=None)`
Main entry point for event monitoring.

**Parameters:**
- `event_name` (str): Type of event (e.g., "login_attempt", "toggle_device", "power_reading", "execute_command", "api_call")
- `user_role` (str): User role ("ADMIN", "MANAGER", "USER", "SYSTEM")
- `user_id` (str): Unique user identifier
- `source_id` (str): IP address or device ID
- `timestamp` (datetime, optional): Event timestamp (defaults to now)
- `context` (dict, optional): Additional context data

**Returns:**
- `bool`: True if threat detected, False otherwise

#### `get_threat_summary()`
Returns a summary of all detected threats including counts by level and type.

**Returns:**
- `dict`: Summary containing total threats, threat levels, threat types, and recent threats

### Context Data Requirements

Different event types expect specific keys in the context dictionary:

- **login_attempt**: `{"success": bool, "session_token": str, "user_agent": str}`
- **toggle_device**: `{"device_id": str, "action": str}`
- **power_reading**: `{"device_id": str, "value": float}`
- **execute_command**: `{"command": str}`
- **api_call**: `{"endpoint": str, "session_token": str, "user_agent": str}`

## Configuration Parameters

The following parameters can be modified in the `AttackDetector` class:

- `MAX_FAILED_LOGINS = 5`: Maximum failed logins before triggering alert
- `LOGIN_WINDOW_MINUTES = 1`: Time window for counting failed logins
- `MAX_TOGGLE_COMMANDS = 10`: Maximum toggle commands before triggering alert
- `TOGGLE_WINDOW_SECONDS = 30`: Time window for counting toggle commands
- `POWER_SPIKE_THRESHOLD = 1.5`: Multiplier for detecting power spikes (150% of average)
- `BUSINESS_HOURS_START = 8`: Start of business hours (24-hour format)
- `BUSINESS_HOURS_END = 18`: End of business hours (24-hour format)
- `SUSPICIOUS_COMMAND_THRESHOLD = 5`: Maximum commands before triggering excessive execution alert
- `COMMAND_WINDOW_MINUTES = 5`: Time window for counting command executions
- `SESSION_TIMEOUT_MINUTES = 30`: Session timeout for hijacking detection

## Important Information

- **Thread Safety:** The `AttackDetector` uses a `threading.Lock` to ensure that concurrent calls to the `instrument` method are handled safely, preventing race conditions when updating internal state.
- **Timestamps:** The system relies heavily on timestamps to correlate events within specific time windows. Ensure that event timestamps are accurate.
- **Context Data:** The richness of the `context` dictionary provided to the `instrument` method is crucial for effective detection. Different detection mechanisms expect different keys in the context.
- **Performance:** The detector maintains in-memory tracking of events. For production use, consider implementing data cleanup mechanisms for long-running systems.
- **Extensibility:** The system is designed to be extensible. New detection methods can be added to the `AttackDetector` class and integrated into the main `instrument` method.
- **False Positives:** The role-aware filtering during business hours helps reduce false positives for legitimate administrative activities, but fine-tuning may be needed based on specific organizational needs.

## Example Output

When running the Jupyter notebook, you'll see output similar to:

```
TESTING BRUTE FORCE LOGIN ATTACK:
  Login attempt  1 | Threat detected: NO
  Login attempt  2 | Threat detected: NO
  ...
  Login attempt  6 | Threat detected: YES

TESTING DEVICE TOGGLE SPAM ATTACK:
  Toggle command  1 | Threat detected: NO
  ...
  Toggle command 11 | Threat detected: YES

TESTING SESSION HIJACKING DETECTION:
  Scenario 2: Session hijacking - different IP
    Hijacked API call | Threat detected: YES
```

## Troubleshooting

1. **FileNotFoundError for suspicious_patterns.json**: The system will fall back to default patterns if the file is missing. Check the console for error messages.
2. **No threats detected during testing**: Ensure that test scenarios exceed the configured thresholds and are not filtered out by role-aware business hours logic.
3. **Unit tests failing**: Ensure no `security_alerts.json` file exists before running tests, as the test suite manages this file.
